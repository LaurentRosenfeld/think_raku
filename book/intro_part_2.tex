% intro_part_2.tex -- Introduction to second part
%
% \chapter{Introduction to the Second part of this book}

Now that you have reached the end of the first part 
of this book, you should non longer be a pure beginner. 
By now, you should be able to go through the official 
Perl~6 documentation (\url{https://docs.perl6.org}) 
and find your way. 

There are many more things to say about programming. 
The next three chapters will be devoted to more 
advanced concepts and new programming paradigms, including:
\begin{description}

\item[Object-oriented programming] We will describe how 
we can construct our own types and methods, which 
is a way to extend the language.

\item[Using grammars] This is a form of declarative 
programming in which you define axioms and rules 
and derive knowledge from these; grammars are a 
very powerful way to analyze textual content and 
are used to transform program source code into 
executable statements.

\item[Functional programming] This is yet another programming 
paradigm in which computation is expressed as the 
evaluation of mathematical functions.
\end{description}

Each of these chapters probably deserves a full 
book in its own right (and might have one some day), 
but we hope to tell you enough about them to get you 
going. In my opinion, every programmer should know 
about these powerful concepts in order to be able 
to select the best way to solve a given problem.

Perl~6 is a multiparadigm language, so we can 
really cover these topics in terms of the Perl~6 
language. A number of subjects that we have 
introduced in previous chapters should lead you 
easily into these new ideas, and this is the 
reason why I think it is possible to properly cover 
them with just one chapter for each of these subjects.

There will be far fewer exercises in the second part, 
because we expect you by now to be able to think up 
your own exercises and make your own experiments for 
yourself. And there will be only very few suggested solutions, 
because we are getting at a level where there is really not  
one right solution, but many possible ways to tackle 
a problem.

Concerning the Perl language, we have covered a lot of 
material, but, as I warned from the very beginning, 
this is far from exhaustive. The following are among 
the topics that we have not covered (and will not cover); 
you might want to explore the documentation on them 
yourself:

\begin{description}
\item[Concurrent programming] Today's computers have 
multiple processors or multicore processors; Perl~6 
offers various ways of taking advantage of these to 
run computing processes in parallel in order to 
improve performance and reduce run time; see 
\url{https://docs.perl6.org/language/concurrency} 
for more details.

\item[Exception handling] Managing situations where 
something goes wrong is an important part of 
programming. Perl~6 offers various mechanisms to 
handle such situations. See \url{https://docs.perl6.org/language/exceptions} 
for more details.

\item[Interprocess communication:] Programs often have to 
run other programs and to communicate with them. See 
\url{https://docs.perl6.org/language/ipc}.

\item[Modules] How to create, use, and distribute Perl~6 
modules. See \url{https://docs.perl6.org/language/modules}.

\item[Native calling interface] How to call libraries 
that are written in other programming languages and 
follow the C calling conventions. 
See \url{https://docs.perl6.org/language/nativecall}

\end{description}